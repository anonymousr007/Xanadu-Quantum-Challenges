#! /usr/bin/python3

import sys
from pennylane import numpy as np
import pennylane as qml


def generating_fourier_state(n_qubits, m):
    """Function which, given the number of qubits and an integer m, returns the circuit and the angles that generate the state
    QFT|m> following the above template.
    Args:
        - n_qubits (int): number of qubits in the circuit.
        - m (int): basis state that we generate. For example, for 'm = 3' and 'n_qubits = 4'
        we would generate the state QFT|0011> (3 in binary is 11).
    Returns:
       - (qml.QNode): circuit used to generate the state.
       - (list[float]): angles that generate the state QFT|m>.
    """

    dev = qml.device("default.qubit", wires=n_qubits)

    @qml.qnode(dev)
    def circuit(angles):
        """Quantum Circuit that will be used as an ansatz for generating the fourier basis.
        Args:
            - angles (list[float]): angles that generate the state QFT|m>.
        
        Returns:
            - (list[float]): probability distribution of the circuit after measurement.
        """

        for i in range(n_qubits):
            qml.Hadamard(wires=i)
            qml.RZ(angles[i], wires=i)

        # We apply QFT^-1 to return to the computational basis.
        qml.adjoint(qml.QFT)(wires=range(n_qubits))

        # We return the probabilities of seeing each basis state.
        return qml.probs(wires=range(n_qubits))

    def error(angles):
        """Returns the error generated by the variational circuit.
        Args:
            - angles (list[float]): angles that generate the state QFT|m>.
        Returns:
            - float: error function of the variational circuit.
        """

        return (1-circuit(angles)[m])**2/len(angles)

    opt = qml.AdamOptimizer(stepsize=0.8)
    epochs = 3500

    angles = np.zeros(n_qubits, requires_grad=True)

    for epoch in range(epochs):
        angles = opt.step(error, angles)
        angles = np.clip(angles, -2 * np.pi, 2 * np.pi) #setting the angles between -2π and 2π

    return circuit, angles


if __name__ == "__main__":
    inputs = sys.stdin.read().split(",")
    n_qubits = int(inputs[0])
    m = int(inputs[1])

    output = generating_fourier_state(n_qubits, m)
    output[0](output[1])
    dev = qml.device("default.qubit", wires=n_qubits)

    @qml.qnode(dev)
    def check_with_arbitrary_state():
        for i in range(n_qubits):
            qml.RY(i, wires=i)
        for op in output[0].qtape.operations:
            qml.apply(op)
        return qml.state()

    print(",".join([f"{p.real.round(5)},{p.imag.round(5)}" for p in check_with_arbitrary_state()]))
